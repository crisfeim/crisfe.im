# Making the AI suffer so you don't have to

Hace unos meses escrib√≠ un mini-experimento para generar c√≥digo a partir de unit tests con inteligencia artificial.

Al final lo tuve empolvado mucho tiempo, hasta que hace poco lo retom√© [desde cero](https://github.com/crisfeim/cli-tddbuddy).

En este art√≠culo quiero compartir los resultados.

## Idea

Mis interacciones con la *IA* se pueden reducir a un bucle: 

A partir de un prompt inicial *(1)*, el modelo genera c√≥digo *(2)* que pruebo en un entorno de dev *(3)*. Si falla *(4)*, env√≠o ese *output* al modelo para que regenere c√≥digo (5). Repito el proceso hasta que el c√≥digo funcione. [^0]

1. üë®‚Äçüíª ‚Üí ü§ñ 
2. ü§ñ ‚Üí üë®‚Äçüíª 
3. üë®‚Äçüíª ‚Üí ‚öôÔ∏è 
4. ‚öôÔ∏è ‚Üí üî¥ 
5. ‚Ü™Ô∏é 1

El prompt inicial sigue siendo el mismo, lo √∫nico que cambia es la adici√≥n del *output* del paso *4*, que usamos como feedback. 

Me pregunt√© si pod√≠a eliminarme de la ecuaci√≥n, concretamente, de los pasos 2 y 3:

```
@todo: insertar mp4 (animaci√≥n en v√≠deo que pasa de este estado):
üë®‚Äçüíª ‚Üí ü§ñ ‚Üí üë®‚Äçüíª ‚Üí ‚öôÔ∏è ‚Äîüî¥‚Üí üë®‚Äçüíª ‚Üí ü§ñ ‚Üí üë®‚Äçüíª ‚Üí ‚öôÔ∏è ... ‚Üí üü¢

a este:
üë®‚Äçüíª ‚Üí ü§ñ ‚Üí ‚öôÔ∏è ‚Üí ü§ñ ‚Üí ‚öôÔ∏è ‚Üí ... ‚Üí üü¢
```

El sue√±o era lograr un flujo en el que mi trabajo se convirtiese en escribir unas *specs*, darle al bot√≥ de ejecuci√≥n, irme a tomar un caf√© y volver 3 horas despu√©s para encontrarme el trabajo hecho[^8].

Para ello, se me ocurri√≥[^1] una idea sencilla: un bucle automatizado basado en un enfoque TDD.

A partir de una prueba unitaria inicial, cuyo sistema sea un *SUT* inexistente, pedir√≠a al modelo la generaci√≥n de ese *SUT*.

Para que quede m√°s claro, este es un ejemplo sencillo de *spec*:

```swift
func test_adder() {
	let sut = Adder(1,3)
	XCTAssertEqual(sut.result, 4)
}
```

Si le pedimos al modelo que implemente el *SUT*, querremos que nos devuelva:

```swift
struct Adder {
	let result: Int
	init(_ a: Int, _ b: Int) {
		result = a + b
	}
}
```

Usar una prueba unitaria como prompt permite que el modelo (ü§ñ) se conecte directamente con el entorno de ejecuci√≥n (‚öôÔ∏è), automatizando la verificaci√≥n del c√≥digo y el env√≠o de feedback.

Si la compilaci√≥n y el test pasan sin errores, rompemos el bucle:

1. üë®‚Äçüíª ‚Üí üìã ‚Üí ü§ñ
2. ü§ñ ‚Üí ‚öôÔ∏è -üî¥‚Üí ü§ñ ‚Üí ‚öôÔ∏è ... ‚Üí üü¢


## Implementaci√≥n

### Ejecuci√≥n de c√≥digo

Para mi primer prototipo, us√© Swift y un enfoque *naive* que consisti√≥ en usar el m√©todo `assert(Bool)` como *framework* de testing[^3].

Para ejecutar el c√≥digo generado con su test, simplemente los concatenamos en una √∫nica cadena y se la pasamos al compilador:

```bash
// Ejemplo de una posible implementaci√≥n
let concatenated = generatedCode + " " + unitTestsSpecs
let tmpFileURL = tmFileURLWithTimestamp("generated.swift")
swiftRunner.runCode(at: tmpFileURL)
```

El c√≥digo del *runner* est√° disponible [aqu√≠](@todo)

### Dise√±o y componentes del sistema

Cuando dise√±o un sistema, enumero las acciones, y asocio cada una con un "actor", "responsable" o componente si se prefiere.

En el caso de este sistema, en un inicio me plante√© estos componentes:

1. ü§ñ Cliente LLM: Genera c√≥digo a partir de las specs.
2. ü™¢ *Concatenator*: Concatena el *output* del modelo con el test inicial.
3. ‚öôÔ∏è *Runner*: Ejecutar la concatenaci√≥n y devuelve un *output*.

*Pseudo-c√≥digo*:

```
System.generateCodeFrom(specs) ‚Üí (GeneratedCode, Stdout/Stderr)
				‚Üí LLM.send(specs) ‚Üí GeneratedCode
				‚Üí Concatenator.concatenate(GeneratedCode, Specs) ‚Üí Concatenated
				‚Üí SwiftRunner.run(Concatenated) ‚Üí Stdout/Stderr
				‚Üí Exit
```

En la implementaci√≥n final, los actores pueden ser *closures* o *protocolos* (*interfaces* en otros lenguajes). No importa.

Es cuesti√≥n de preferencia. Lo importante es poder inyectarlos para testear que se llaman cuando y como corresponde:

```swift
protocol Client {
	func send(_ specs: String) async throws -> String
}

protocol Runner {
	func run(_ code: String) throws -> ProcessOutput 
}

typealias Concatenator = (String, String) -> String
```


Dado que el sistema result√≥ m√°s complejo, al final termin√© con este dise√±o:

system.png

### Limitaciones
	
	Aunque no he tenido la oportunidad de probar exhaustivamente este enfoque, aqu√≠ hay algunos ejemplos y limitaciones que me encontr√© en el camino.
	
### Cuando Codestral te da una palmadita y te dice: ‚Äúte dejo el resto como ejercicio‚Äù

Partiendo de estas *specs*:

```swift
func test_fetch_repositories_with_minimum_stars_from_real_api() async throws {
				let sut = GithubClient()
				// This MUST PERFORM A REAL CALL TO THE GITHUB API
				let repos = try await sut.fetchRepositories(minStars: 100)
				print(repos)
				if repos.count == 0 {
								fail("List should not be empty")
				}
					
					if !repos.allSatisfy { $0.stars >= 100 } {
								fail("Fetched repositories should have at least 100 hundred stars")
				}
}

try await test_fetch_repositories_with_minimum_stars_from_real_api()

func fail(_ description: String, function: String = #function) {
				print("‚ùå ‚Äî \(function), \(description)")
}
```

...a pesar de algunas dificultades iniciales, *Codestral* fue capaz de generar un cliente **funcional**:

```swift
struct Repository: Decodable {
				let name: String
				let stargazers_count: Int
				var stars: Int { stargazers_count }
}

class GithubClient {
				func fetchRepositories(minStars: Int) async throws -> [Repository] {
								let url = URL(string: "https://api.github.com/search/repositories?q=stars:>\(minStars)&sort=stars")!
								let (data, _) = try await URLSession.shared.data(from: url)
								let results = try JSONDecoder().decode(SearchResults<Repository>.self, from: data)
								return results.items
				}
}

struct SearchResults<T: Decodable>: Decodable {
				let items: [T]
}
```

Tuve que insistir en que hiciese una petici√≥n real (v√©ase el comentario desesperado dentro del propio test) [^5], porque el modelo se empe√±aba en generarme cosas de este tipo:

```swift
class GithubClient {
				func fetchRepositories(minStars: Int) async throws -> [Repository] {
	/* YOUR IMPLEMENTATION HERE */
							return ...
				}
}
```

~~Gracias, Codestral. Con eso y un croquis, ya casi tengo un sistema distribuido.~~

### Cuando el modelo no resuelve el problema... porque ya sabe la respuesta

Aunque poco frecuente, otro caso que me encontr√© ocasionalmente, fue el de *outputs hardcodeados*. Ej:

```swift
func test_adder() {
	let sut = Adder(1,3)
	assert(sut.result == 4)
}
```

El modelo generaba esto:

```swift
struct Adder {
	let result = 4 
	init (_ a: Int, _ b: Int) {}
}
```

Esto se soluciona f√°cilmente a√±adiendo m√°s aserciones al test, para obligar al modelo a generalizar[^6].

```swift
func test_adder() {
	var sut = Adder(1,3)
	assert(sut.result == 4)
	
	sut = Adder(3, 4)
	assert(sut.result == 7)
	
	sut = Adder(5, 4)
	assert(sut.result == 9)
}
```


### Cuando el modelo quiere ser tu profe, pero t√∫ solo quieres compilar

En [mi system prompt](/system-prompt.txt), el siguiente apartado es importante para que el c√≥digo pueda compilar correctamente:

> Provide ONLY runnable Swift code. No explanations, comments, or formatting (no code blocks, markdown, symbols, or text).

Algunos modelos, ~ejem ejem *Codestral*~, ten√≠an dificultades entendiendo el contexto y se empe√±aban en encapsular el c√≥digo en bloques de c√≥digo de markdown, acompa√±√°ndolo adem√°s de comentarios explicativos.

Y aunque se agradece el entusiasmo por la pedagog√≠a, hubiera preferido que no me obligara a escribir una funci√≥n de preprocessing para limpiar los artefactos de su output.

En la [reescritura del proyecto](https://github.com/crisfeim/cli-tddbuddy), he usado s√≥lo *Llama 3.2*. Por el momento ~~no he tenido que ponerle cinta adhesiva en la boca.~~ no me he encontrado con este problema.

### Conclusiones

A pesar de las limitaciones descritas y de que mis pruebas han sido bastante modestas, intuyo que es un enfoque prometedor y que se har√° un hueco en la industria a medida de que las herramientas se hagan m√°s sofisticadas.[^7]

¬øQui√©n sabe? Puede que alg√∫n d√≠a nuestro cotidiano como ingenieros de software se reduzca a escribir *specs*.

Creo que el reto real es integrar esta metodolog√≠a en un *tooling* existente (*Xcode, por ejemplo*). Dada la simplicidad del enfoque, dir√≠a que es m√°s bien un reto de experiencia de usuario, que de implementaci√≥n.
	
Por otro lado, me hubiera gustado integrar un framework de testing real [^2], pero prefer√≠ centrarme primero en tener una prueba de concepto funcional. Queda como tarea pendiente, tambi√©n recabar datos cuantitativos (n√∫mero de iteraciones necesarias para resolver "X" problema, etc....).

### Demo en l√≠nea

> Un playground vale m√°s que mil palabras.

Puedes probar el concepto interactuando con este playground. 

Necesitar√°s una clave de *Gemini*. Si no te sientes c√≥modo introduciendo tu clave, puedes auditar el c√≥digo en [Github](@todo:enlace) o incluso, [descargar el playground como html](@todo:enlace) y usarlo en local con *Llama 3.2*.

[^0]: Esta es una simplificaci√≥n del proceso
[^1]: A m√≠ y [a otros trescientos desarrolladores que creen haber inventado el TDD inverso en 2023](@todo enlace trescientos repos github).
[^2]: *XCTest* / *Swift Testing*
[^3]: El m√©todo assert lanza un trap en tiempo de ejecuci√≥n cuando la condici√≥n es falsa, generando salida por *stderr* (en *builds* de *debug*), lo que lo hace √∫til como se√±al de error para este sistema
[^5]: De ah√≠ el comentario desesperado en may√∫sculas dentro del c√≥digo: *"This MUST PERFORM A REAL CALL TO THE GITHUB API"*
[^6]: > Hardcode this. I dare you motherfucker. ‚Äî Jules, si supiera Swift.
[^7]: Ya existen SaaS dedicados a esto
[^8]: Admito que fantase√© con la idea de que esto me diese una ventaja competitiva. Me dur√≥ poco la tonter√≠a, cuando vi que, obviamente, no hab√≠a sido el primero en tener esta "brillante" idea. Gracias globalizaci√≥n, una vez m√°s destrozas los sue√±os de ese chico salido de las monta√±as de Colombia.


